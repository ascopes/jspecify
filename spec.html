<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JSpecify nullness spec draft &mdash; JSpecify  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="JSpecify user guide" href="user-guide.html" />
    <link rel="prev" title="JSpecify: Standard Java annotations for static analysis" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> JSpecify
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">JSpecify nullness spec draft</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#temporary-advice-to-readers-non-normative">Temporary advice to readers (non-normative)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-word-nullable">The word “nullable”</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-scope-of-this-spec">The scope of this spec</a></li>
<li class="toctree-l3"><a class="reference internal" href="#that-s-all">That’s all!</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#normative-and-non-normative-sections">Normative and non-normative sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references-to-concepts-defined-by-this-spec">References to concepts defined by this spec</a></li>
<li class="toctree-l2"><a class="reference internal" href="#base-type">Base type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-components">Type components</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-operator">Nullness operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type">Augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#details-common-to-all-annotations">Details common to all annotations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-type-use-annotation">The type-use annotation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recognized-locations-for-type-use-annotations">Recognized locations for type-use annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-declaration-annotation">The declaration annotation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recognized-locations-for-declaration-annotations">Recognized locations for declaration annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#null-marked-scope">Null-marked scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-a-type-usage-appearing-in-code">Augmented type of a type usage appearing in code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-type-of-an-intersection-type">Augmented type of an intersection type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-unbounded-wildcard">Bound of an “unbounded” wildcard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bound-of-an-object-bounded-type-parameter">Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#augmented-null-types">Augmented null types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-worlds">Multiple “worlds”</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#propagating-how-many-worlds-a-relation-must-hold-in">Propagating how many worlds a relation must hold in</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#same-type">Same type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtyping">Subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtyping">Nullness subtyping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-inclusive-under-every-parameterization">Null-inclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#null-exclusive-under-every-parameterization">Null-exclusive under every parameterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-path">Nullness-subtype-establishing path</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-subtype-establishing-direct-supertype-edges">Nullness-subtype-establishing direct-supertype edges</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullness-delegating-subtyping-rules-for-java">Nullness-delegating subtyping rules for Java</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containment">Containment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#substitution">Substitution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#applying-a-nullness-operator-to-an-augmented-type">Applying a nullness operator to an augmented type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capture-conversion">Capture conversion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="user-guide.html">JSpecify user guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">JSpecify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>JSpecify nullness spec draft</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/spec.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="jspecify-nullness-spec-draft">
<h1>JSpecify nullness spec draft<a class="headerlink" href="#jspecify-nullness-spec-draft" title="Permalink to this headline"></a></h1>
<p>This document is our draft specification for the semantics of a set of nullness
annotations.</p>
<hr class="docutils" />
<section id="temporary-advice-to-readers-non-normative">
<h2>Temporary advice to readers (non-normative)<a class="headerlink" href="#temporary-advice-to-readers-non-normative" title="Permalink to this headline"></a></h2>
<p>For someone new to our nullness annotations, this document does not make a good
introduction. This document is targeted more at tool authors or advanced users.
New users will prefer to start with our <a class="reference internal" href="user-guide.html"><span class="doc std std-doc">User Guide</span></a>. We are working on further
user documentation, including Javadoc.</p>
<section id="the-word-nullable">
<h3>The word “nullable”<a class="headerlink" href="#the-word-nullable" title="Permalink to this headline"></a></h3>
<p>In this doc, I aim not to refer to whether a type “is nullable.” Instead, I draw
some distinctions, creating roughly 3 kinds of “Is it nullable?” questions we
can ask for any given type usage. Each kind is derived (at least in part) from
the previous:</p>
<ol class="arabic simple">
<li><p>Does <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code> appear directly on that type usage?</p></li>
<li><p>What is the <a class="reference external" href="#nullness-operator">nullness operator</a> of that type usage?</p></li>
<li><p>For that type usage…</p>
<ul class="simple">
<li><p>Is it “reasonable” to assume that is not <code class="docutils literal notranslate"><span class="pre">null</span></code>?</p></li>
<li><p>Is it “reasonable” to put a <code class="docutils literal notranslate"><span class="pre">null</span></code> into it?</p></li>
<li><p>neither (what we sometimes call “parametric nullness”)</p></li>
<li><p>both (as can happen with <a class="reference external" href="#nullness-operator">nullness operator</a> <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> under lenient
tools)</p></li>
</ul>
</li>
</ol>
</section>
<section id="the-scope-of-this-spec">
<h3>The scope of this spec<a class="headerlink" href="#the-scope-of-this-spec" title="Permalink to this headline"></a></h3>
<p>Currently, this spec does not address <em>when</em> tools must apply any part of the
spec. For example, it does not state when tools must check that the <a class="reference external" href="#subtyping">subtyping</a>
relation holds.</p>
<p>We anticipate that tools will typically apply parts of this spec in the same
cases that they apply the corresponding parts of the Java Language
Specification. For example, if code contains the parameterized type
<code class="docutils literal notranslate"><span class="pre">List&lt;&#64;Nullable</span> <span class="pre">Foo&gt;</span></code>, we anticipate that tools will check that <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">Foo</span></code>
is a subtype of the bound of the type parameter of <code class="docutils literal notranslate"><span class="pre">List</span></code>.</p>
<p>However, this is up to tool authors, who may have reasons to take a different
approach. For example:</p>
<ul class="simple">
<li><p>Java <a class="reference external" href="https://github.com/jspecify/jspecify/issues/49">places some restrictions that aren’t necessary for soundness</a>,
and it
<a class="reference external" href="https://github.com/jspecify/jspecify/issues/65">is lenient in at least one way that can lead to runtime errors</a>.</p></li>
<li><p>JSpecify annotations can be used even by tools that are not “nullness
checkers” at all. For example, a tool that lists the members of an API could
show the nullness of each type in the API, without any checking that those
types are “correct.”</p></li>
<li><p>Even when a tool is a “nullness checker,” it might be written for another
language, like Kotlin, with its own rules for when to perform type checks.
Or the tool might target a future version of Java whose language features
would not be covered by this version of this spec.</p></li>
</ul>
<p>Note also that this spec covers only nullness information <em>from JSpecify
annotations</em>. Tools may have additional sources of information. For example, a
tool may recognize additional annotations. Or a tool may define a rule to treat
all unannotated type usages the same, rather than implementing different
behavior for those that this spec assigns “unspecified nullness.”</p>
</section>
<section id="that-s-all">
<h3>That’s all!<a class="headerlink" href="#that-s-all" title="Permalink to this headline"></a></h3>
<p>On to the spec.</p>
</section>
</section>
<hr class="docutils" />
<section id="normative-and-non-normative-sections">
<h2>Normative and non-normative sections<a class="headerlink" href="#normative-and-non-normative-sections" title="Permalink to this headline"></a></h2>
<p>This document contains some non-normative comments to emphasize points or to
anticipate likely questions. Those comments are set off as block quotes.</p>
<blockquote>
<div><p>This is an example of a non-normative comment.</p>
</div></blockquote>
<p>This document also links to other documents. Those documents are non-normative,
except for when we link to the Java Language Specification to defer to its
rules.</p>
</section>
<section id="references-to-concepts-defined-by-this-spec">
<span id="concept-references"></span><h2>References to concepts defined by this spec<a class="headerlink" href="#references-to-concepts-defined-by-this-spec" title="Permalink to this headline"></a></h2>
<p>When a rule in this spec refers to any concept that is defined in this spec (for
example, <a class="reference external" href="#substitution">substitution</a> or <a class="reference external" href="#containment">containment</a>), apply this spec’s definition (as
opposed to other definitions, such as the ones in the JLS).</p>
<p>Additionally, when a rule in this spec refers to a JLS rule that in turn refers
to a concept that is defined in this spec, likewise apply this spec’s
definition.</p>
<p>In particular, when a JLS rule refers to types, apply this spec’s definition of
<a class="reference external" href="#augmented-type">augmented types</a> (as oppposed to <a class="reference external" href="#base-type">base types</a>).</p>
</section>
<section id="base-type">
<h2>Base type<a class="headerlink" href="#base-type" title="Permalink to this headline"></a></h2>
<p>A <em>base type</em> is a type as defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html">JLS 4</a>.</p>
<blockquote>
<div><p>JLS 4 does not consider type-use annotations to be part of types, so neither
does our concept of “base type.”</p>
</div></blockquote>
</section>
<section id="type-components">
<h2>Type components<a class="headerlink" href="#type-components" title="Permalink to this headline"></a></h2>
<p>A <em>type component</em> of a given type is a type that transitively forms some part
of that type. Specifically, a type component is one of the following:</p>
<ul class="simple">
<li><p>a non-wildcard type argument</p></li>
<li><p>a wildcard bound</p></li>
<li><p>an array component type</p></li>
<li><p>an enclosing type</p></li>
<li><p>an element of an intersection type</p></li>
<li><p>the entire type</p></li>
</ul>
</section>
<section id="nullness-operator">
<h2>Nullness operator<a class="headerlink" href="#nullness-operator" title="Permalink to this headline"></a></h2>
<p>A nullness operator is one of 4 values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
</ul>
<blockquote>
<div><p>The informal meaning of the operators is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>: This is the operator produced by putting <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code> on a
type usage.</p>
<ul>
<li><p>The type usage <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNION_NULL</span></code> includes <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span></code>,
etc., plus <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
<li><p>The type-variable usage <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">UNION_NULL</span></code> includes all members of <code class="docutils literal notranslate"><span class="pre">T</span></code>,
plus <code class="docutils literal notranslate"><span class="pre">null</span></code> if it wasn’t already included.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: This is the operator produced by <em>not</em> putting <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code> on
a type usage (aside from the exception discussed under <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>
below).</p>
<ul>
<li><p>The type usage <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code> includes <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span></code>, etc.,
without including <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
<li><p>The type-variable usage <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">NO_CHANGE</span></code> includes exactly the members of
<code class="docutils literal notranslate"><span class="pre">T</span></code>: If <code class="docutils literal notranslate"><span class="pre">null</span></code> was a member of <code class="docutils literal notranslate"><span class="pre">T</span></code>, then it’s a member of <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">NO_CHANGE</span></code>. If it was not a member of <code class="docutils literal notranslate"><span class="pre">T</span></code>, then it is not a member of
<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>One way to conceptualize this is that <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code> means
“non-null <code class="docutils literal notranslate"><span class="pre">String</span></code>” but that <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">NO_CHANGE</span></code> means “nullness comes from
the value of <code class="docutils literal notranslate"><span class="pre">T</span></code>.”</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>: This is the operator produced by not putting <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code> on
a type usage <em>in code that is outside a <a class="reference external" href="#null-marked-scope">null-marked scope</a></em>. Roughly, it
is the operator assigned to “completely unannotated code.”</p>
<ul>
<li><p>The type usage <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code> includes <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span></code>,
etc., but the developer did not specify whether to include <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p></li>
<li><p>The type-variable usage <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">UNSPECIFIED</span></code> includes all members of <code class="docutils literal notranslate"><span class="pre">T</span></code>.
But the developer did not specify whether to add <code class="docutils literal notranslate"><span class="pre">null</span></code> if it wasn’t
already included.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>: This operator not only does not <em>add</em> <code class="docutils literal notranslate"><span class="pre">null</span></code> but also
actively <em>removes</em> it from a type-variable usage that would otherwise
include it.</p>
<ul>
<li><p>The type usage <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">MINUS_NULL</span></code> includes <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;b&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span></code>,
etc., without including <code class="docutils literal notranslate"><span class="pre">null</span></code>. (This is equivalent to <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code>.)</p></li>
<li><p>The type-variable usage <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">MINUS_NULL</span></code> includes all members of <code class="docutils literal notranslate"><span class="pre">T</span></code>
<em>except</em> for <code class="docutils literal notranslate"><span class="pre">null</span></code>. (This is equivalent to <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">NO_CHANGE</span></code> unless
<code class="docutils literal notranslate"><span class="pre">null</span></code> was a member of <code class="docutils literal notranslate"><span class="pre">T</span></code>.)</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</section>
<section id="augmented-type">
<h2>Augmented type<a class="headerlink" href="#augmented-type" title="Permalink to this headline"></a></h2>
<p>An augmented type consists of a <a class="reference external" href="#base-type">base type</a> and a <a class="reference external" href="#nullness-operator">nullness operator</a>
corresponding to <em>each</em> of its <a class="reference external" href="#type-components">type components</a>.</p>
<blockquote>
<div><p>Arguably, an augmented type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> is better
understood not as representing “a type” but as representing a <em>lack</em> of the
nullness portion of the type.</p>
</div></blockquote>
<p>For our purposes, base types (and thus augmented types) include not just class
and interface types, array types, and type variables but also
<a class="reference external" href="#intersection-types">intersection types</a> and the null type.</p>
<blockquote>
<div><p>This spec aims to define rules for augmented types compatible with those that
the JLS defines for base types.</p>
<p>Accordingly, in almost all cases, this spec agrees with the JLS’s rules when
specifying what <em>base</em> types appear in a piece of code. It makes an exception
for <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard,”</a> for which it
specifies a bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code> that the JLS does not specify.</p>
</div></blockquote>
<p>When this spec uses capital letters, they refer to augmented types (unless
otherwise noted). This is in contrast to the JLS, which typically uses them to
refer to base types.</p>
<p>When this spec refers to “the nullness operator of” a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, it refers
specifically to the nullness operator of the type component that is the entire
type <code class="docutils literal notranslate"><span class="pre">T</span></code>, without reference to the nullness operator of any other type
components of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<blockquote>
<div><p>For example, “the nullness operator of <code class="docutils literal notranslate"><span class="pre">List&lt;Object&gt;</span></code>” refers to whether the
list itself may be <code class="docutils literal notranslate"><span class="pre">null</span></code>, not whether its elements may be.</p>
</div></blockquote>
</section>
<section id="details-common-to-all-annotations">
<h2>Details common to all annotations<a class="headerlink" href="#details-common-to-all-annotations" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The package name is <code class="docutils literal notranslate"><span class="pre">org.jspecify.nullness</span></code>. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/1">#1</a>]</p></li>
<li><p>The Java module name is <code class="docutils literal notranslate"><span class="pre">org.jspecify</span></code>. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/181">#181</a>]</p></li>
<li><p>The Maven artifact is <code class="docutils literal notranslate"><span class="pre">org.jspecify:jspecify</span></code>. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/181">#181</a>]</p></li>
</ul>
<p>All annotations have runtime retention. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/28">#28</a>] None of the annotations are
marked <a class="reference external" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/annotation/Repeatable.html">repeatable</a>.</p>
</section>
<section id="the-type-use-annotation">
<h2>The type-use annotation<a class="headerlink" href="#the-type-use-annotation" title="Permalink to this headline"></a></h2>
<p>We provide a parameterless type-use annotation called <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>.</p>
<section id="recognized-locations-for-type-use-annotations">
<h3>Recognized locations for type-use annotations<a class="headerlink" href="#recognized-locations-for-type-use-annotations" title="Permalink to this headline"></a></h3>
<p>A location is a <em>recognized</em> location for our type-use annotation in the
circumstances detailed below. A type at a recognized location has the semantics
described in this spec. The spec does not assign semantics to types in other
locations, nor to any annotations on such types.</p>
<blockquote>
<div><p>For now, we’ve chosen to restrict ourselves to API locations for which tools
mostly agree on what it means for a type in that location to be <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>.</p>
</div></blockquote>
<p>The following locations are recognized except when overruled by one of the
exceptions in the subsequent sections: [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<ul>
<li><p>return type of a method</p></li>
<li><p>formal parameter type of a method or constructor, as defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-8.html#jls-8.4.1">JLS 8.4.1</a></p>
<blockquote>
<div><p>This excludes the receiver parameter.</p>
</div></blockquote>
</li>
<li><p>field type</p></li>
<li><p>type parameter upper bound [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/60">#60</a>]</p></li>
<li><p>non-wildcard type argument</p></li>
<li><p>wildcard bound</p></li>
<li><p>array component type</p></li>
<li><p>type used in a variadic parameter declaration</p></li>
</ul>
<p>However, any location above is unrecognized if it matches either of the
following cases: [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<blockquote>
<div><p>We refer to these cases (and some other cases below) as “intrinsically
non-nullable.”</p>
</div></blockquote>
<ul>
<li><p>a type usage of a primitive type</p></li>
<li><p>the outer type that qualifies an inner type</p>
<blockquote>
<div><p>For example, the annotation in <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">Foo.Bar</span></code> is in an unrecognized
location: Java syntax attaches it to the outer type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p>Every outer type is intrinsically non-nullable because every instance of
an inner class has an associated instance of the outer class.</p>
</div></blockquote>
</li>
</ul>
<p>Additionally, any location above is unrecognized if it makes up <em>any
<a class="reference external" href="#type-components">type component</a></em> of a type in the following locations: [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<blockquote>
<div><p>These locations all fit under the umbrella of “implementation code.”
Implementation code may use types that contain type arguments, wildcard
bounds, and array component types, which would be recognized locations if not
for the exceptions defined by this section.</p>
</div></blockquote>
<ul class="simple">
<li><p>a local variable type</p></li>
<li><p>an exception parameter</p></li>
<li><p>the type in a cast expression</p></li>
<li><p>an array or object creation expression</p></li>
<li><p>an explicit type argument supplied to a generic method or constructor
(including via a member reference) or to an instance creation expression for
a generic class</p></li>
</ul>
<blockquote>
<div><p>In practice, we anticipate that tools will treat types (and their annotations)
in <em>most</em> of the above locations much like they treat types in other
locations. Still, this spec does not concern itself with implementation code:
We believe that the most important domain for us to focus on is that of APIs.</p>
</div></blockquote>
<p>All locations that are not explicitly listed as recognized are unrecognized.</p>
<blockquote>
<div><p>Other notable unrecognized annotations include: [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/17">#17</a>]</p>
<p>Some additional intrinsically non-nullable locations:</p>
<ul class="simple">
<li><p>supertype in a class declaration</p></li>
<li><p>thrown exception type</p></li>
<li><p>enum constant declaration</p></li>
<li><p>receiver parameter type</p></li>
</ul>
<p>Some other locations that individual tools are more likely to assign semantics
to:</p>
<ul class="simple">
<li><p>a class declaration [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/7">#7</a>]: For example, the annotation in <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">&#64;Nullable</span> <span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{}</span></code> is in an unrecognized location.</p></li>
<li><p>a type-parameter declaration or a wildcard <em>itself</em> [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/19">#19</a>, <a class="reference external" href="https://github.com/jspecify/jspecify/issues/31">#31</a>]</p></li>
<li><p>any <a class="reference external" href="#type-components">type component</a> of a receiver parameter type [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/157">#157</a>]</p></li>
</ul>
<p>But note that types “inside” some of these locations can still be recognized,
such as a <em>type argument</em> of a supertype.</p>
</div></blockquote>
<blockquote>
<div><p>When analyzing source code, tools are encouraged to offer an option to issue
an error for an annotation in an unrecognized location (unless they define
semantics for that location). Tools are especially encouraged to issue an
error for an annotation in a location that is intrinsically non-nullable. When
reading <em>bytecode</em>, however, tools may be best off ignoring an annotation in
an unrecognized location (again, unless they define semantics for that
location).</p>
</div></blockquote>
</section>
</section>
<section id="the-declaration-annotation">
<h2>The declaration annotation<a class="headerlink" href="#the-declaration-annotation" title="Permalink to this headline"></a></h2>
<p>We provide a single parameterless declaration annotation called <code class="docutils literal notranslate"><span class="pre">&#64;NullMarked</span></code>.
[<a class="reference external" href="https://github.com/jspecify/jspecify/issues/5">#5</a>, <a class="reference external" href="https://github.com/jspecify/jspecify/issues/87">#87</a>]</p>
<section id="recognized-locations-for-declaration-annotations">
<h3>Recognized locations for declaration annotations<a class="headerlink" href="#recognized-locations-for-declaration-annotations" title="Permalink to this headline"></a></h3>
<p>Our declaration annotation is specified to be <em>recognized</em> when applied to the
locations listed below:</p>
<ul class="simple">
<li><p>A <em>named</em> class.</p></li>
<li><p>A package. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/34">#34</a>]</p></li>
<li><p>A module. [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/34">#34</a>]</p></li>
</ul>
<blockquote>
<div><p><em>Not</em> a method [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/43">#43</a>], constructor [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/43">#43</a>], or field [<a class="reference external" href="https://github.com/jspecify/jspecify/issues/50">#50</a>].</p>
</div></blockquote>
</section>
</section>
<section id="null-marked-scope">
<h2>Null-marked scope<a class="headerlink" href="#null-marked-scope" title="Permalink to this headline"></a></h2>
<p>To determine whether a type usage appears in a null-marked scope:</p>
<p>Look for an <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.NullMarked</span></code> annotation on any of the
enclosing scopes surrounding the type usage.</p>
<p>Class members are enclosed by classes, which may be enclosed by other class
members or classes. and top-level classes are enclosed by packages, which may be
enclosed by modules.</p>
<blockquote>
<div><p>Packages are <em>not</em> enclosed by “parent” packages.</p>
</div></blockquote>
<blockquote>
<div><p>This definition of “enclosing” likely matches
<a class="reference external" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.compiler/javax/lang/model/element/Element.html#getEnclosingElement()">the definition in the Java compiler API</a>.</p>
</div></blockquote>
<p>If one of those scopes is directly annotated with
<code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.NullMarked</span></code>, then the type usage is in a null-marked
scope. Otherwise, it is not.</p>
</section>
<section id="augmented-type-of-a-type-usage-appearing-in-code">
<span id="augmented-type-of-usage"></span><h2>Augmented type of a type usage appearing in code<a class="headerlink" href="#augmented-type-of-a-type-usage-appearing-in-code" title="Permalink to this headline"></a></h2>
<p>For most type usages in source code or bytecode on which JSpecify nullness
annotations are <a class="reference external" href="#recognized-locations-for-type-use-annotations">recognized</a>, this section defines how to determine their
<a class="reference external" href="#augmented-type">augmented types</a>. Note, however, that rules for specific cases below take
precedence over the general rule here.</p>
<p>Because the JLS already has rules for determining the <a class="reference external" href="#base-type">base type</a> for a type
usage, this section covers only how to determine its <a class="reference external" href="#nullness-operator">nullness operator</a>.</p>
<p>To determine the nullness operator, apply the following rules in order. Once one
condition is met, skip the remaining conditions.</p>
<ul class="simple">
<li><p>If the type usage is annotated with <code class="docutils literal notranslate"><span class="pre">&#64;org.jspecify.nullness.Nullable</span></code>, its
nullness operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If the type usage appears in a <a class="reference external" href="#null-marked-scope">null-marked scope</a>, its nullness operator is
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
<li><p>Its nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
</ul>
<blockquote>
<div><p>The choice of nullness operator is <em>not</em> affected by any nullness operator
that appears in a corresponding location in a supertype. For example, if one
type declares a method whose return type is annotated <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, and if
another type overrides that method but does not declare the return type as
<code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>, then the override’s return type will <em>not</em> have nullness operator
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p>The rules here never produce the fourth nullness operator, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.
However, if tool authors prefer, they can safely produce <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> in any
case in which it is equivalent to <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. For example, there is no
difference between <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code> and <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">MINUS_NULL</span></code>.</p>
</div></blockquote>
<blockquote>
<div><p>So why does <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> exist at all? It does appear later in this spec in
the section on <a class="reference external" href="#substitution">substitution</a>. However, its main purpose is to provide tools
with a way to represent the nullness of certain expressions in implementation
code: Consider <code class="docutils literal notranslate"><span class="pre">ArrayList&lt;E&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">ArrayList</span></code> supports null elements, so the
class has to handle the possibility that any expression of type <code class="docutils literal notranslate"><span class="pre">E</span></code> may be
null. However, if implementation code contains the statement <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(e</span> <span class="pre">!=</span> <span class="pre">null)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>, then tools can assume that <code class="docutils literal notranslate"><span class="pre">e</span></code> is non-null inside. The purpose of
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> is to represent that such an expression is known not to be null,
even though its base type <code class="docutils literal notranslate"><span class="pre">E</span></code> suggests otherwise.</p>
</div></blockquote>
</section>
<section id="augmented-type-of-an-intersection-type">
<span id="intersection-types"></span><h2>Augmented type of an intersection type<a class="headerlink" href="#augmented-type-of-an-intersection-type" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>Technically speaking, the JLS does not define syntax for an intersection type.
Instead, it defines a syntax for type parameters and casts that supports
multiple types. Then the intersection type is derived from those. Intersection
types can also arise from operations like <a class="reference external" href="#capture-conversion">capture conversion</a>. See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.9">JLS 4.9</a>.</p>
<p>One result of this is that it’s never possible for a programmer to write an
annotation “on an intersection type.”</p>
</div></blockquote>
<p>This spec assigns a <a class="reference external" href="#nullness-operator">nullness operator</a> to each individual element of an
intersection type, following our normal rules for type usages. It also assigns a
nullness operator to the intersection type as a whole. The nullness operator of
the type as a whole is always <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>This lets us provide, for every <a class="reference external" href="#base-type">base type</a>, a rule for computing its
<a class="reference external" href="#augmented-type">augmented type</a>. But we require <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> so as to avoid questions like
whether “a <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> intersection type whose members are <code class="docutils literal notranslate"><span class="pre">Foo</span> <span class="pre">UNION_NULL</span></code>
and <code class="docutils literal notranslate"><span class="pre">Bar</span> <span class="pre">UNION_NULL</span></code>” is a subtype of “a <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> intersection type with
those same members.” Plus, it would be difficult for tools to output the
nullness operator of an intersection type in a human-readable way.</p>
</div></blockquote>
<blockquote>
<div><p>To avoid ever creating an intersection type with a nullness operator other
than <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, we define special handling for intersection types under
<a class="reference external" href="#applying-operator">“Applying a nullness operator to an augmented type.”</a></p>
</div></blockquote>
</section>
<section id="bound-of-an-unbounded-wildcard">
<span id="unbounded-wildcard"></span><h2>Bound of an “unbounded” wildcard<a class="headerlink" href="#bound-of-an-unbounded-wildcard" title="Permalink to this headline"></a></h2>
<p>In source, an unbounded wildcard is written as <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. This section does <strong>not</strong>
apply to <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, even though that is often equivalent to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>.</p>
<blockquote>
<div><p>See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS 4.5.1</a>.</p>
</div></blockquote>
<p>In bytecode, such a wildcard is represented as a wildcard type with an empty
list of upper bounds and an empty list of lower bounds. This section does
<strong>not</strong> apply to a wildcard with any bounds in either list, even a sole upper
bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code>.</p>
<blockquote>
<div><p>For a wildcard with an explicit bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>, perhaps with an annotation on <code class="docutils literal notranslate"><span class="pre">Object</span></code>), instead apply
<a class="reference external" href="#augmented-type-of-usage">the normal rules</a> for the explicit bound type.</p>
</div></blockquote>
<p>If an unbounded wildcard appears in a <a class="reference external" href="#null-marked-scope">null-marked scope</a>, then it has a single
upper bound whose <a class="reference external" href="#base-type">base type</a> is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose <a class="reference external" href="#nullness-operator">nullness operator</a> is
<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<p>If an unbounded wildcard appears outside a null-marked scope, then it has a
single upper bound whose base type is <code class="docutils literal notranslate"><span class="pre">Object</span></code> and whose nullness operator is
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>In both cases, we specify a bound that does not exist in the source or
bytecode, deviating from the JLS. Because the base type of the bound is
<code class="docutils literal notranslate"><span class="pre">Object</span></code>, this should produce no user-visible differences except to tools that
implement JSpecify nullness analysis.</p>
</div></blockquote>
<p>Whenever a JLS rule refers specifically to <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>, disregard it, and instead
apply the rules for <code class="docutils literal notranslate"><span class="pre">&lt;?</span> <span class="pre">extends</span> <span class="pre">T&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> has a base type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and
the nullness operator defined by this section.</p>
</section>
<section id="bound-of-an-object-bounded-type-parameter">
<span id="object-bounded-type-parameter"></span><h2>Bound of an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter<a class="headerlink" href="#bound-of-an-object-bounded-type-parameter" title="Permalink to this headline"></a></h2>
<p>In source, an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter can be writen in either of 2 ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> with no JSpecify nullness type annotations on the bound</p></li>
</ul>
<blockquote>
<div><p>See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.4">JLS 4.4</a>.</p>
</div></blockquote>
<p>In bytecode, <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;T</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> are both represented as a type
parameter with a single upper bound, <code class="docutils literal notranslate"><span class="pre">Object</span></code>, and no JSpecify nullness type
annotations on the bound.</p>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears in a <a class="reference external" href="#null-marked-scope">null-marked scope</a>, then its
bound has a <a class="reference external" href="#base-type">base type</a> of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a <a class="reference external" href="#nullness-operator">nullness operator</a> of <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<blockquote>
<div><p>Note that this gives <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> a different bound than <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code> (though only in a
null-marked scope).</p>
</div></blockquote>
<p>If an <code class="docutils literal notranslate"><span class="pre">Object</span></code>-bounded type parameter appears outside a null-marked scope, then
its bound has a base type of <code class="docutils literal notranslate"><span class="pre">Object</span></code> and a nullness operator of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p>
<blockquote>
<div><p>All these rules match the behavior of
<a class="reference external" href="#augmented-type-of-usage">our normal rules</a> for determining the
<a class="reference external" href="#augmented-type">augmented type</a> of the bound <code class="docutils literal notranslate"><span class="pre">Object</span></code>. The only “special” part is that we
consider the source code <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span></code> to have a bound of <code class="docutils literal notranslate"><span class="pre">Object</span></code>, just as it does
when compiled to bytecode.</p>
</div></blockquote>
</section>
<section id="augmented-null-types">
<span id="null-types"></span><h2>Augmented null types<a class="headerlink" href="#augmented-null-types" title="Permalink to this headline"></a></h2>
<p>The JLS refers to “the null type.” In this spec, we assign a <a class="reference external" href="#nullness-operator">nullness operator</a>
to all types, including the null type. This produces multiple null types:</p>
<ul>
<li><p>the null <a class="reference external" href="#base-type">base type</a> with nullness operator <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: the
“bottom”/”nothing” type used in <a class="reference external" href="#capture-conversion">capture conversion</a></p>
<blockquote>
<div><p>No value, including <code class="docutils literal notranslate"><span class="pre">null</span></code> itself, has this type.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p>
<blockquote>
<div><p>This is equivalent to the previous type. Tools may use the 2
interchangeably.</p>
</div></blockquote>
</li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>: the type of the null
reference</p></li>
<li><p>the null base type with nullness operator <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code></p>
<blockquote>
<div><p>This may be relevant only in implementation code.</p>
</div></blockquote>
</li>
</ul>
</section>
<section id="multiple-worlds">
<span id="id1"></span><h2>Multiple “worlds”<a class="headerlink" href="#multiple-worlds" title="Permalink to this headline"></a></h2>
<p>Some of the rules in this spec come in 2 versions: One version requires a
property to hold “in all worlds,” and the other requires it to hold only “in
some world.”</p>
<p>Tool authors may choose to implement neither, either, or both versions of the
rules.</p>
<blockquote>
<div><p>Our goal is to allow tools and their users to choose their desired level of
strictness in the presence of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. The basic idea is that, every
time a tool encounters a type component with the nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>, it has the option to fork off 2 “worlds”: 1 in which the
operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> and 1 in which it is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
<p>In more detail: When tools lack a nullness specification for a type, they may
choose to assume that either of the resulting worlds may be the “correct”
specification. The all-worlds version of a rule, by requiring types to be
compatible in all possible worlds, holds that types are incompatible unless it
has enough information to prove they are compatible. The some-world version,
by requiring types to be compatible only in <em>some</em> world, holds that types are
compatible unless it has enough information to prove they are incompatible.
(By behaving “optimistically,” the some-world version is much like Kotlin’s
rules for “platform types.”)</p>
<p>Thus, a strict tool might choose to implement the all-worlds version of rules,
and a lenient tool might choose to implement the some-world version. Yet
another tool might implement both and let users select which rules to apply.</p>
<p>Still another possibility is for a tool to implement both versions and to use
that to distinguish between “errors” and “warnings.” Such a tool might always
first process code with the all-worlds version and then with the some-world
version. If the tools detects, say, an out-of-bounds type argument in both
cases, the tool would produce an error. But, if the tool detects such a
problem with the all-worlds version but not with the some-world version, the
tool would produce a warning.</p>
</div></blockquote>
<p>The main body of each section of the spec describes the all-worlds rule. If the
some-world rule differs, the differences are explained at the end.</p>
<blockquote>
<div><p>A small warning: To implement the full some-world rules, a tool must also
implement at least part of the all-worlds rules. Those rules are required as
part of <a class="reference external" href="#substitution">substitution</a>.</p>
</div></blockquote>
<section id="propagating-how-many-worlds-a-relation-must-hold-in">
<span id="propagating-multiple-worlds"></span><h3>Propagating how many worlds a relation must hold in<a class="headerlink" href="#propagating-how-many-worlds-a-relation-must-hold-in" title="Permalink to this headline"></a></h3>
<p>When one rule in this spec refers to another, it refers to the same version of
the rule. For example, when the rules for <a class="reference external" href="#containment">containment</a> refer to the rules for
<a class="reference external" href="#subtyping">subtyping</a>, the some-world containment relation refers to the some-world
subtyping relation, and the all-worlds containment relation refers to the
all-worlds subtyping relation.</p>
<p>This meta-rule applies except when a rule refers explicitly to a particular
version of another rule.</p>
</section>
</section>
<section id="same-type">
<h2>Same type<a class="headerlink" href="#same-type" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> are the same type if <code class="docutils literal notranslate"><span class="pre">S</span></code> is a <a class="reference external" href="#subtyping">subtype</a> of <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code> is a subtype
of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
<p>The same-type relation is <em>not</em> defined to be reflexive or transitive.</p>
<blockquote>
<div><p>For more discussion of reflexive and transitive relations, see the comments
under <a class="reference external" href="#nullness-subtyping">nullness subtyping</a>.</p>
</div></blockquote>
</section>
<section id="subtyping">
<h2>Subtyping<a class="headerlink" href="#subtyping" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the following conditions are met:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a <a class="reference external" href="#nullness-subtyping">nullness subtype</a> of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> according to the
<a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating subtyping rules for Java</a>.</p></li>
</ul>
<blockquote>
<div><p>The first condition suffices for most cases. The second condition is necessary
only for types that have subcomponents — namely, parameterized types and
arrays. And it essentially says “Check the first condition on subcomponents as
appropriate.”</p>
</div></blockquote>
</section>
<section id="nullness-subtyping">
<h2>Nullness subtyping<a class="headerlink" href="#nullness-subtyping" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> is a nullness subtype of <code class="docutils literal notranslate"><span class="pre">F</span></code> if any of the following conditions are met:</p>
<blockquote>
<div><p>Nullness subtyping asks the question: If <code class="docutils literal notranslate"><span class="pre">A</span></code> includes <code class="docutils literal notranslate"><span class="pre">null</span></code>, does <code class="docutils literal notranslate"><span class="pre">F</span></code> also
include <code class="docutils literal notranslate"><span class="pre">null</span></code>? There are 3 cases in which this is true, 2 easy and 1 hard:</p>
</div></blockquote>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is <a class="reference external" href="#null-inclusive-under-every-parameterization">null-inclusive under every parameterization</a>.</p>
<blockquote>
<div><p>This is the first easy case: <code class="docutils literal notranslate"><span class="pre">F</span></code> always includes <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> is <a class="reference external" href="#null-exclusive-under-every-parameterization">null-exclusive under every parameterization</a>.</p>
<blockquote>
<div><p>This is the second easy case: <code class="docutils literal notranslate"><span class="pre">A</span></code> never includes <code class="docutils literal notranslate"><span class="pre">null</span></code>.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing path</a> to any type whose base type
is the same as the base type of <code class="docutils literal notranslate"><span class="pre">F</span></code>, and <code class="docutils literal notranslate"><span class="pre">F</span></code> does <em>not</em> have
<a class="reference external" href="#nullness-operator">nullness operator</a> <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p>
<blockquote>
<div><p>This is the hard case: A given type-variable usage does not necessarily
always include <code class="docutils literal notranslate"><span class="pre">null</span></code>, nor does it necessarily always exclude <code class="docutils literal notranslate"><span class="pre">null</span></code>. (For
example, consider a usage of <code class="docutils literal notranslate"><span class="pre">E</span></code> inside <code class="docutils literal notranslate"><span class="pre">ArrayList&lt;E&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">ArrayList</span></code> may be
instantiated as either an <code class="docutils literal notranslate"><span class="pre">ArrayList&lt;&#64;Nullable</span> <span class="pre">String&gt;</span></code> or an
<code class="docutils literal notranslate"><span class="pre">ArrayList&lt;String&gt;</span></code>.)</p>
<p>Subtyping questions for type-variable usages are more complex: <code class="docutils literal notranslate"><span class="pre">E</span></code> is a
nullness subtype of <code class="docutils literal notranslate"><span class="pre">E</span></code>; <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">E</span></code> is not. Similarly, if <code class="docutils literal notranslate"><span class="pre">&lt;F</span> <span class="pre">extends</span> <span class="pre">E&gt;</span></code>, then <code class="docutils literal notranslate"><span class="pre">F</span></code> is a nullness subtype of <code class="docutils literal notranslate"><span class="pre">E</span></code>. But if <code class="docutils literal notranslate"><span class="pre">&lt;F</span> <span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">E&gt;</span></code>, it is not.</p>
</div></blockquote>
</li>
</ul>
<blockquote>
<div><p>A further level of complexity in all this is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>. For example, in
the <a class="reference external" href="#multiple-worlds">all-worlds</a> version of the following rules, a type with nullness operator
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code> can be both null-<em>inclusive</em> under every parameterization and
null-<em>exclusive</em> under every parameterization.</p>
</div></blockquote>
<p>Nullness subtyping (and thus subtyping itself) is <em>not</em> defined to be reflexive
or transitive.</p>
<blockquote>
<div><p>If we defined nullness subtyping to be reflexive, then <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code>
would be a subtype of <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code>, even under the <a class="reference external" href="#multiple-worlds">all-worlds</a> rules.
In other words, we’d be saying that unannotated code is always free from
nullness errors. That is clearly false. (Nevertheless, lenient tools will
choose not to issue errors for such code. They can do this by implementing the
<a class="reference external" href="#multiple-worlds">some-world</a> rules.)</p>
<p>If we defined nullness subtyping to be transitive, then we’d say that <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNION_NULL</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code> under the some-world rules.
That would happen because of a chain of subtyping rules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNION_NULL</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code>.</p></li>
</ul>
<p>Therefore, <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNION_NULL</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code>.</p>
<p>Yes, it’s pretty terrible for something called “subtyping” not to be reflexive
or transitive. A more accurate name for this concept would be “consistent,” a
term used in gradual typing. However, we use “subtyping” anyway. In our
defense, we need to name multiple concepts, including not just subtyping but
also the <a class="reference external" href="#same-type">same-type</a> relation and <a class="reference external" href="#containment">containment</a>. If we were to coin a new term
for each, tool authors would need to mentally map between those terms and the
analogous Java terms. (Still, yes: Feel free to read terms like “subtyping” as
if they hvae scare quotes around them.)</p>
<p>Subtyping does end up being transitive when the relation is required to hold
in all worlds. And it does end up being reflexive when the relation is
required to hold only in <a class="reference external" href="#multiple-worlds">some world</a>. We don’t state those properties as
rules for 2 reasons: First, they arise naturally from the definitions. Second,
we don’t want to suggest that subtyping is reflexive and transitive under both
versions of the rule.</p>
</div></blockquote>
<p>Contrast this with our <a class="reference external" href="#nullness-delegating-subtyping">nullness-delegating subtyping</a> rules and <a class="reference external" href="#containment">containment</a>
rules: Each of those is defined as a transitive closure. However, this is
incorrect, and we should fix it: Transitivity causes the same problem there as
it does here: <code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">String&gt;</span></code> ends up as a subtype of <code class="docutils literal notranslate"><span class="pre">List&lt;?</span> <span class="pre">extends</span> <span class="pre">String&gt;</span></code> because of a chain of subtyping rules that uses <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code> as part of the intermediate step. Luckily, tool authors that set
out to implement transitivity for these two rules are very unlikely to write
code that “notices” this chain. So, in practice, users are likely to see the
“mostly transitive” that we intend, even if we haven’t found a way to formally
specify it yet.</p>
</section>
<section id="null-inclusive-under-every-parameterization">
<h2>Null-inclusive under every parameterization<a class="headerlink" href="#null-inclusive-under-every-parameterization" title="Permalink to this headline"></a></h2>
<p>A type is null-inclusive under every parameterization if it meets either of the
following conditions:</p>
<ul>
<li><p>Its <a class="reference external" href="#nullness-operator">nullness operator</a> is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p>
<blockquote>
<div><p>This is the simplest part of the simplest case: A type usage always
includes <code class="docutils literal notranslate"><span class="pre">null</span></code> if it’s annotated with <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>.</p>
</div></blockquote>
</li>
<li><p>It is an <a class="reference external" href="#intersection-types">intersection type</a> whose elements all are null-inclusive under
every parameterization.</p></li>
</ul>
<p><strong>Some-world version:</strong> The rule is the same except that the requirement for
“<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
<blockquote>
<div><p>That is: It’s possible that any type usage in unannotated code “ought to be”
annotated with <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span></code>.</p>
</div></blockquote>
</section>
<section id="null-exclusive-under-every-parameterization">
<h2>Null-exclusive under every parameterization<a class="headerlink" href="#null-exclusive-under-every-parameterization" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>This is a straightforward concept (“never includes <code class="docutils literal notranslate"><span class="pre">null</span></code>”), but it’s not as
simple to implement as the null-<em>inclusive</em> rule was. This null-<em>exclusive</em>
rule has to cover cases like <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">E</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;E</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code>), and
<code class="docutils literal notranslate"><span class="pre">E</span></code> (where <code class="docutils literal notranslate"><span class="pre">&lt;E</span> <span class="pre">extends</span> <span class="pre">&#64;Nullable</span> <span class="pre">Object&gt;</span></code> but nearby code has performed a null
check on the expression). The case of <code class="docutils literal notranslate"><span class="pre">&lt;E</span> <span class="pre">extends</span> <span class="pre">Object&gt;</span></code> is an example of
why the following rule requires looking for a “path.”</p>
</div></blockquote>
<p>A type is null-exclusive under every parameterization if it has a
<a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing path</a> to either of the following:</p>
<ul>
<li><p>any type whose <a class="reference external" href="#nullness-operator">nullness operator</a> is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>any augmented class or array type</p>
<blockquote>
<div><p>This rule refers specifically to a “class or array type,” as distinct from
other types like type variables and <a class="reference external" href="#intersection-types">intersection types</a>.</p>
</div></blockquote>
</li>
</ul>
<blockquote>
<div><p>When code dereferences an expression, we anticipate that tools will check
whether the expression is null-exclusive under every parameterization.</p>
</div></blockquote>
</section>
<section id="nullness-subtype-establishing-path">
<h2>Nullness-subtype-establishing path<a class="headerlink" href="#nullness-subtype-establishing-path" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>Note that this definition is used both by the definition of
<a class="reference external" href="#null-inclusive-under-every-parameterization">null-inclusive under every parameterization</a> and by the third condition in
the definition <a class="reference external" href="#nullness-subtyping">nullness subtyping</a> itself (the “type-variable case”).</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> has a nullness-subtype-establishing path to <code class="docutils literal notranslate"><span class="pre">F</span></code> if both of the following
hold:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> has <a class="reference external" href="#nullness-operator">nullness operator</a> <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>There is a path from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">F</span></code> through
<a class="reference external" href="#nullness-subtype-establishing-direct-supertype-edges">nullness-subtype-establishing direct-supertype edges</a>.</p>
<blockquote>
<div><p>The path may be empty. That is, <code class="docutils literal notranslate"><span class="pre">A</span></code> has a nullness-subtype-establishing
path to itself — as long as it has one of the required nullness
operators.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Some-world version:</strong> The rules are the same except that the requirement for
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</section>
<section id="nullness-subtype-establishing-direct-supertype-edges">
<h2>Nullness-subtype-establishing direct-supertype edges<a class="headerlink" href="#nullness-subtype-establishing-direct-supertype-edges" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>This section defines the supertypes for a given type — but limited to those
that matter for nullness checking. For example, there’s no need for the rules
to reflect that <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code> extends <code class="docutils literal notranslate"><span class="pre">Object</span> <span class="pre">NO_CHANGE</span></code>: If we’ve
established that a type has a path to <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">NO_CHANGE</span></code>, then we already know
that it’s <a class="reference external" href="#null-exclusive-under-every-parameterization">null-exclusive under every parameterization</a>, based on the rules
above, and that’s enough to prove subtyping. And if we <em>haven’t</em> established
that, then the <code class="docutils literal notranslate"><span class="pre">String</span></code>-<code class="docutils literal notranslate"><span class="pre">Object</span></code> edge isn’t going to change that.</p>
<p>Thus, the rules here are restricted to type variables and intersection types,
whose supertypes may have nullness annotations.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> has nullness-subtype-establishing direct-supertype edges to the union of the
nodes computed by the following 2 rules:</p>
<p>Upper-bound rule:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented <a class="reference external" href="#intersection-types">intersection type</a>: all the intersection type’s
elements whose <a class="reference external" href="#nullness-operator">nullness operator</a> is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">T</span></code> is an augmented type variable: all the corresponding type parameter’s
upper bounds whose nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code></p></li>
<li><p>otherwise: no nodes</p></li>
</ul>
<p>Lower-bound rule:</p>
<ul>
<li><p>the augmented type <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">NO_CHANGE</span></code> for every type variable <code class="docutils literal notranslate"><span class="pre">C</span></code> whose lower
bound meets both of the following conditions:</p>
<blockquote>
<div><p>This rule specifies “<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">NO_CHANGE</span></code>” instead of just “<code class="docutils literal notranslate"><span class="pre">C</span></code>” because our
definition of <a class="reference external" href="#nullness-subtype-establishing-path">nullness-subtype-establishing path</a> operates on augmented
types. However, the nullness operator does not matter in this case: After
the initial check of the nullness operator of the type called “<code class="docutils literal notranslate"><span class="pre">A</span></code>” above,
no steps of the process look at the nullness operator of the “from” node.</p>
</div></blockquote>
<!-- TODO(cpovirk): Figure out whether the path's "*from* type" could be a
base type instead of an augmented type. Maybe I've been sticking with an
augmented type because that provides better access to bounds in our
prototype... possibly because the augmented types reflect
substitution/asMemberOf operations?? -->
<ul class="simple">
<li><p>Its <a class="reference external" href="#base-type">base type</a> is the same as <code class="docutils literal notranslate"><span class="pre">T</span></code>’s base type.</p></li>
<li><p>Its nullness operator is <em>not</em> <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
</ul>
</li>
</ul>
<blockquote>
<div><p>In short, whether you have a <code class="docutils literal notranslate"><span class="pre">Predicate&lt;?</span> <span class="pre">super</span> <span class="pre">String&gt;</span></code>, a <code class="docutils literal notranslate"><span class="pre">Predicate&lt;?</span> <span class="pre">super</span> <span class="pre">&#64;Nullable</span> <span class="pre">String&gt;</span></code>, or unannotated code that doesn’t specify the nullness
operator for the bound, you can always pass its <code class="docutils literal notranslate"><span class="pre">test</span></code> method a <code class="docutils literal notranslate"><span class="pre">String</span></code>. (If
you want to pass a <code class="docutils literal notranslate"><span class="pre">&#64;Nullable</span> <span class="pre">String</span></code>, then you’ll need for the bound to be
<a class="reference external" href="#null-inclusive-under-every-parameterization">null-inclusive under every parameterization</a>. The existence of the
null-inclusiveness rule frees this current rule from having to cover that
case.)</p>
</div></blockquote>
<p><strong>Some-world version:</strong> The rules are the same except that the requirements for
“<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code> or <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>” are loosened to “<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>, <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, or
<code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</section>
<section id="nullness-delegating-subtyping-rules-for-java">
<span id="nullness-delegating-subtyping"></span><h2>Nullness-delegating subtyping rules for Java<a class="headerlink" href="#nullness-delegating-subtyping-rules-for-java" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>Recall that this rule exists to handle subcomponents of types — namely, type
arguments and array component types: It essentially says “Check nullness
subtyping for subcomponents as appropriate.”</p>
</div></blockquote>
<p>The Java subtyping rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.10">JLS 4.10</a>. (Each rule takes a type as
input and produces zero or more direct supertypes as outputs.) We add to them as
follows:</p>
<ul>
<li><p><a class="reference external" href="#concept-references">As always</a>, interpret the Java rules as operating on
<a class="reference external" href="#augmented-type">augmented types</a>, not <a class="reference external" href="#base-type">base types</a>. This raises the question of <em>how</em> to
extend these particular rules to operate on augmented types. The answer has
two parts:</p>
<ul>
<li><p>The first part applies only to the nullness operator <em>“of the type.”</em>
<a class="reference external" href="#augmented-type">As always</a>, this means the nullness operator of the
type component that is the entire type.</p>
<p>No matter what nullness operator the input augmented type has, the rules
still apply, and they still produce the same direct supertypes. Thanks
to that rule, the nullness operator of any <em>produced supertype</em> is never
read by the subtyping rules, so any nullness operator is valid for it,
too.</p>
<blockquote>
<div><p>Essentially, this rule says that the top-level types do no matter:
They have already been checked by the <a class="reference external" href="#nullness-subtyping">nullness subtyping</a> check.</p>
<p>For simplicity, we recommend producing a nullness operator of
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>: That operator is valid for all types, including
<a class="reference external" href="#intersection-types">intersection types</a>.</p>
</div></blockquote>
</li>
<li><p>The nullness operators of <em>subcomponents</em> of the augmented types <em>do</em>
matter. For example, some Java rules produce subtypes only if
subcomponents meet certain requirements.
<a class="reference external" href="#concept-references">As always</a>, check those requirements by applying
<em>this spec’s</em> definitions.</p>
<blockquote>
<div><p>Those definitions (like <a class="reference external" href="#containment">containment</a>) refer back to definitions (like
<a class="reference external" href="#nullness-subtyping">nullness subtyping</a>) that use the nullness operator of the types in
question.</p>
</div></blockquote>
</li>
</ul>
</li>
<li><p>When the Java array rules require one type to be a <em>direct</em> supertype of
another, consider the direct supertypes of <code class="docutils literal notranslate"><span class="pre">T</span></code> to be <em>every</em> type that <code class="docutils literal notranslate"><span class="pre">T</span></code>
is a <a class="reference external" href="#subtyping">subtype</a> of.</p></li>
</ul>
</section>
<section id="containment">
<h2>Containment<a class="headerlink" href="#containment" title="Permalink to this headline"></a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-4.html#jls-4.5.1">JLS 4.5.1</a>. We add to them as follows:</p>
<ul>
<li><p>Disregard the 2 rules that refer to a bare <code class="docutils literal notranslate"><span class="pre">?</span></code>. Instead, treat <code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is
specified by <a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>The rule written specifically for <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code> applies only if the
nullness operator of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>When the JLS refers to the same type <code class="docutils literal notranslate"><span class="pre">T</span></code> on both sides of a rule, the rule
applies if and only if this spec defines the 2 types to be the <a class="reference external" href="#same-type">same type</a>.</p></li>
</ul>
<p><strong>Some-world version:</strong> The rules are the same except that the requirement for
“<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>” is loosened to “<code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.”</p>
</section>
<section id="substitution">
<h2>Substitution<a class="headerlink" href="#substitution" title="Permalink to this headline"></a></h2>
<blockquote>
<div><p>Substitution on Java base types barely requires an explanation: See <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-1.html#jls-1.3">JLS 1.3</a>.
Substitution on <a class="reference external" href="#augmented-type">augmented types</a>, however, is trickier: If <code class="docutils literal notranslate"><span class="pre">Map.get</span></code> returns
<code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">UNION_NULL</span></code>, and if a user has a map whose value type is <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span></code>, then what does its <code class="docutils literal notranslate"><span class="pre">get</span></code> method return? Naive substitution would
produce <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">UNSPECIFIED</span> <span class="pre">UNION_NULL</span></code>. To reduce that to a proper augmented
type with a single nullness operator, we define this process.</p>
</div></blockquote>
<p>To substitute each type argument <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code> for each corresponding type parameter
<code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>:</p>
<p>For every type-variable usage <code class="docutils literal notranslate"><span class="pre">V</span></code> whose <a class="reference external" href="#base-type">base type</a> is <code class="docutils literal notranslate"><span class="pre">Pᵢ</span></code>, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with
the result of the following operation:</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">V</span></code> is <a class="reference external" href="#null-exclusive-under-every-parameterization">null-exclusive under every parameterization</a> in <a class="reference external" href="#multiple-worlds">all worlds</a>,
then replace it with the result of <a class="reference external" href="#applying-operator">applying</a>
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code> to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p>
<blockquote>
<div><p>This is the one instance in which a rule specifically refers to the
<a class="reference external" href="#multiple-worlds">all-worlds</a> version of another rule. Normally,
<a class="reference external" href="#propagating-multiple-worlds">a rule “propagates” its version to other rules</a>.
But in this instance, the null-exclusivity rule (and all rules that it in
turn applies) are the <a class="reference external" href="#multiple-worlds">all-worlds</a> versions.</p>
</div></blockquote>
<blockquote>
<div><p>The purpose of this special case is to improve behavior in “the
<code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder</span></code> case”: Because <code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder.add</span></code> always
throws <code class="docutils literal notranslate"><span class="pre">NullPointerException</span></code> for a null argument, we would like for
<code class="docutils literal notranslate"><span class="pre">add(null)</span></code> to be a compile error, even under lenient tools.
Unfortunately, without this special case, lenient tools could permit
<code class="docutils literal notranslate"><span class="pre">add(null)</span></code> in unannotated code. For an example, read on.</p>
<p>Consider an unannotated user of <code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder&lt;Foo&gt;</span> <span class="pre">builder</span></code>. Its
type argument <code class="docutils literal notranslate"><span class="pre">Foo</span></code> will have a <a class="reference external" href="#nullness-operator">nullness operator</a> of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.
Without this special case, the parameter of <code class="docutils literal notranslate"><span class="pre">builder.add</span></code> would have a
nullness operator of <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>, too. Then, when a lenient tool applies
the <a class="reference external" href="#multiple-worlds">some-world</a> subtyping relation to <code class="docutils literal notranslate"><span class="pre">builder.add(null)</span></code>, the relation
would hold.</p>
<p>To solve this, we need a special case for substitution for null-exclusive
type parameters like the one on <code class="docutils literal notranslate"><span class="pre">ImmutableList.Builder</span></code>. That special case
needs to produce a type with a nullness operator other than <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.
One valid option is to produce <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>; we happened to choose
<code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p>
</div></blockquote>
</li>
<li><p>Otherwise, replace <code class="docutils literal notranslate"><span class="pre">V</span></code> with the result of applying the nullness operator of
<code class="docutils literal notranslate"><span class="pre">V</span></code> to <code class="docutils literal notranslate"><span class="pre">Aᵢ</span></code>.</p></li>
</ul>
</section>
<section id="applying-a-nullness-operator-to-an-augmented-type">
<span id="applying-operator"></span><h2>Applying a nullness operator to an augmented type<a class="headerlink" href="#applying-a-nullness-operator-to-an-augmented-type" title="Permalink to this headline"></a></h2>
<p>The process of applying a <a class="reference external" href="#nullness-operator">nullness operator</a> requires 2 inputs:</p>
<ul class="simple">
<li><p>the nullness operator to apply</p></li>
<li><p>the <a class="reference external" href="#augmented-type">augmented type</a> (which, as always, includes a nullness operator for
that type) to apply it to</p></li>
</ul>
<p>The result of the process is an augmented type.</p>
<p>The process is as follows:</p>
<p>First, based on the pair of nullness operators (the one to apply and the one
from the augmented type), compute a “desired nullness operator.” Do so by
applying the following rules in order. Once one condition is met, skip the
remaining conditions.</p>
<ul class="simple">
<li><p>If the nullness operator to apply is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>, the desired nullness
operator is <code class="docutils literal notranslate"><span class="pre">MINUS_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>, the desired nullness operator
is <code class="docutils literal notranslate"><span class="pre">UNION_NULL</span></code>.</p></li>
<li><p>If either nullness operator is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>, the desired nullness operator
is <code class="docutils literal notranslate"><span class="pre">UNSPECIFIED</span></code>.</p></li>
<li><p>The desired nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p></li>
</ul>
<p>Then, if the input augmented type is <em>not</em> an <a class="reference external" href="#intersection-types">intersection type</a>, the output is
the same as the input but with its nullness operator replaced with the desired
nullness operator.</p>
<p>Otherwise, the output is an intersection type. For every element <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code> of the
input type, the output type has an element that is the result of applying the
desired nullness operator to <code class="docutils literal notranslate"><span class="pre">Tᵢ</span></code>.</p>
<blockquote>
<div><p>In this case, the desired nullness operator is always equal to the nullness
operator to apply that was an input to this process. That’s because the
nullness operator of the intersection type itself is defined to always be
<code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>.</p>
</div></blockquote>
</section>
<section id="capture-conversion">
<h2>Capture conversion<a class="headerlink" href="#capture-conversion" title="Permalink to this headline"></a></h2>
<p>The Java rules are defined in <a class="reference external" href="https://docs.oracle.com/javase/specs/jls/se14/html/jls-5.html#jls-5.1.10">JLS 5.1.10</a>. We add to them as follows:</p>
<ul>
<li><p>The parameterized type that is the output of the conversion has the same
<a class="reference external" href="#nullness-operator">nullness operator</a> as the parameterized type that is the input type.</p></li>
<li><p>Disregard the JLS rule about <code class="docutils literal notranslate"><span class="pre">&lt;?&gt;</span></code>. Instead, treat <code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>, where the <a class="reference external" href="#nullness-operator">nullness operator</a> of the <code class="docutils literal notranslate"><span class="pre">Object</span></code> bound is specified by
<a class="reference external" href="#unbounded-wildcard">“Bound of an unbounded wildcard.”</a></p>
<blockquote>
<div><p>This is just a part of our universal rule to treat a bare <code class="docutils literal notranslate"><span class="pre">?</span></code> like <code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">extends</span> <span class="pre">Object</span></code>.</p>
</div></blockquote>
</li>
<li><p>When a rule generates a lower bound that is the null type, we specify that
its nullness operator is <code class="docutils literal notranslate"><span class="pre">NO_CHANGE</span></code>. (See
<a class="reference external" href="#null-types">“Augmented null types.”</a>)</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="JSpecify: Standard Java annotations for static analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="user-guide.html" class="btn btn-neutral float-right" title="JSpecify user guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2021, The JSpecify Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>